/** 
 * https://github.com/qq449245884/xiaozhi/issues/1
 * 
 * JavaScript引擎
 */

/** 
 * V8引擎由两个主要部件组成:
 * 
 * (1) emory Heap(内存堆) — 内存分配地址的地方
 * (2) Call Stack(调用堆栈) — 代码执行的地方
 */ 

/** 
 * Runtime(运行时)
 * 
 * 有些浏览器的 API 经常被使用到(比如说：setTimeout)，但是，这些 API 却不是引擎提供的。
 * 我们把很多引擎之外的 API（浏览器提供 API）称为 Web API，比如说 DOM、AJAX、setTimeout等等。
 *  */ 

/** 
 * 调用栈
 * 
 * JavaScript是一种单线程编程语言，这意味着它只有一个调用堆栈。因此，它一次只能做一件事。
 * 调用栈是一种数据结构，它记录了我们在程序中的位置。
 * 如果我们运行到一个函数，它就会将其放置到栈顶，当从这个函数返回的时候，就会将这个函数从栈顶弹出，这就是调用栈做的事情。
 * 
 * 每一个进入调用栈的都称为调用帧。
 * 
 * "堆栈溢出"，当你达到调用栈最大的大小的时候就会发生这种情况，而且这相当容易发生，特别是在你写递归的时候却没有全方位的测试它。
 * 
 * 例如：function foo() {
 *          foo()
 *      }
 *      foo();
 *  
 * 当引擎开始执行这段代码时，它首先调用函数“foo”。然而，这个函数是递归的，并且在没有任何终止条件的情况下开始调用自己。
 * 因此，在执行的每一步中，相同的函数都会被一次又一次地添加到调用堆栈中。
 */

/** 
 * 并发与事件循环
 * 
 * 当调用堆栈中的函数调用需要花费大量时间来处理时会发生什么情况? 
 * 例如，假设你希望在浏览器中使用JavaScript进行一些复杂的图像转换。
 * 
 * 你可能会问-为什么这是一个问题?
 * 问题是，当调用堆栈有函数要执行时，浏览器实际上不能做任何其他事情——它被阻塞了，这意味着浏览器不能呈现，
 * 它不能运行任何其他代码，它只是卡住了，如果你想在应用中使用流畅的页面效果，这就会产生问题。
 * 
 * 而且这不是唯一的问题，一旦你的浏览器开始处理调用栈中的众多任务，它可能会停止响应相当长一段时间。
 * 大多数浏览器都会这么做，报一个错误，询问你是否想终止 web 页面。
 * 解决方案是异步回调。
 */


