/** 
 * 词法作用域
 * 
 * 词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的
 * 因此当词法分析器处理代码时会保持作用域不变
 */

/** 
    function foo(a) {
        var b = a * 2;
        function bar(c) {
            console.log( a, b, c );
        }
        bar( b * 3 );
    }
    foo(2); // 2, 4, 12

    引擎执行 console.log(..) 声明，并查找 a、b 和 c 三个变量的引用。
    它首先从最内部的作用域，也就是 bar(..) 函数的作用域气泡开始查找。
    引擎无法在这里找到 a，因此会去上一级到所嵌套的 foo(..) 的作用域中继续查找。
    在这里找到了 a，因此引擎使用了这个引用。对 b 来讲也是一样的。
    而对 c 来说，引擎在 bar(..) 中就找到了它。

    我们需要注意：
    (1)作用域查找会在找到第一个匹配的标识符时停止。
    (2)词法作用域查找只会查找一级标识符，比如 a、b 和 c。
        如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，
        对象属性访问规则会分别接管对 bar 和 baz 属性的访问。
 */

/** 
 * 欺骗词法
 * 
 * JavaScript 中有两种机制来修改词法作用域
 * 需要注意的是：欺骗词法作用域会导致性能下降。
 * 
 * (1)eval
 *      在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，
 *      并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。
 * 
        function foo(str, a) {
            eval( str ); // 欺骗！
            console.log( a, b );
        }
        var b = 2;
        foo( "var b = 3;", 1 );

        eval(..) 调用中的 "var b = 3;" 这段代码会被当作本来就在那里一样来处理。
        由于那段代码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。

        eval(str)这段代码实际上在 foo(..) 内部创建了一个变量 b，并遮蔽了外部（全局）作用域中的同名变量。
 

        但是如果在严格模式下，eval(..)在运行时，有其自己的词法作用域

 * (2)with
        with的作用：with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

        例如：
            var obj = {
                a: 1,
                b: 2,
                c: 3
            };

            // 单调乏味的重复 "obj"
            obj.a = 2;
            obj.b = 3;
            obj.c = 4;

            // 简单的快捷方式
            with (obj) {
                a = 3;
                b = 4;
                c = 5;
            }

        但实际上这不仅仅是为了方便地访问对象属性。考虑如下代码：
            function foo(obj) {
                with (obj) {
                a = 2;
                }
            }
            var o1 = {
                a: 3
            };

            var o2 = {
                b: 3
            };

            foo( o1 );
            console.log( o1.a ); // 2
            foo( o2 );
            console.log( o2.a ); // undefined
            console.log( a ); // 2——不好，a 被泄漏到全局作用域上了！
        
            在 with 块内部，我们写的代码看起来只是对变量a进行简单的词法引用，实际上就是一个LHS引用，并将2赋值给它。
            当 o2 传递进去，o2 并没有 a 属性，因此不会创建这个属性，o2.a 保持 undefined。
            with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对
                象的属性也会被处理为定义在这个作用域中的词法标识符。

            注意：尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的var
                    声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。

                也就是说，但当我们将 o2 作为作用域时，其中并没有 a 标识符，因此进行了正常的 LHS 标识符查找。
                o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a＝2 执行时，自动创建了一个全局变量（因为是非严格模式）。

    (3)性能
        JavaScript 引擎会在编译阶段进行数项的性能优化。
        其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

        但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断
        都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会
        如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底
        是什么。

        最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简
        单的做法就是完全不做任何优化。

        代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪
        明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代
        码会运行得更慢这个事实。
 */

/** 
 * 
 */

