/** 
 * 函数作用域，块作用域
 */

/** 
 * 函数中的作用域
 
    function foo(a) {
        var b = 2;
        var c = 3;
    }

    foo(1);
    console.log(a,b,c); // 报错

    因为：标识符 a、b、c 都附属于foo(..)的作用域气泡。
            因此无法从 foo(..) 的外部对它们进行访问。

 * 函数作用域的含义:属于这个函数的全部变量都可以在整个函数的范围内使用及复用
 */

/** 
 * 隐藏内部实现
 * 从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。
 * 
 * 为什么“隐藏”变量和函数是一个有用的技术？
 * 在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。
 */

/** 
 * 函数作用域
 
    var a = 2;
    function foo() { // <-- 添加这一行
        var a = 3;
        console.log( a ); // 3
    } // <-- 以及这一行

    foo(); // <-- 以及这一行
    console.log( a ); // 2

    如上代码，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。
    但是它并不理想，因为必须声明一个具名函数 foo()，意味着 foo 这个名称本身“污染”了所在作用域。
    其次，必须显式地通过函数名（foo()）调用这个函数才能运行其中的代码。

    如果函数不需要函数名，并且能够自动运行，这将会更加理想。

    解决如下：
    var a = 2;

    (function foo(){ // <-- 添加这一行
        var a = 3;
        console.log( a ); // 3
    })();

    console.log( a ); // 2

    包装函数的声明以 (function...开始，函数会被当作函数表达式。
 */

/** 
 * 区分函数声明和表达式
 * 
 * 看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。
 * 如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式
 */

/** 
 * 匿名和具名
 * 
    setTimeout( function() {
        console.log("I waited 1 second!");
    }, 1000 );

    回调参数，它是匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，
    而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。

    匿名函数的缺点：
    (1) 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用
        ※※：arguments.callee，代表的是对一个函数的引用
    (2) 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

    所以，始终给函数表达式命名是一个最佳实践：
    setTimeout( function timeoutHandler() { // <-- 快看，我有名字了！
        console.log( "I waited 1 second!" );
    }, 1000 );
 */

/** 
 * 立即执行函数表达式
 * 
    var a = 2;
    (function foo() {
        var a = 3;
        console.log( a ); // 3
    })();
    console.log( a ); // 2

    (function foo(){ .. })()    第一个()将函数变成表达式，第二个()执行了这个函数。
 */



