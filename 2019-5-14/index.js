/** 
 * 性能分析
 * 我们把要被测量的代码放到两个计时器调用之间，分别是内置console对象上的time和timeEnd
 * 这里定义定时器nice fish
 * 操作结束以后，用相同的计时器名字去调用console.timeEnd
 */

console.time('nice fish');
for(let i = 0; i < 1000; i++) {
    var a = i;
}
console.timeEnd('nice fish');

/** 
 * 生命周期概览
 * 
 * 当我们输入一个url的时候发生了一些事情：
 * (1)输入url以后，浏览器会生成请求，并发送至服务器
 * (2)服务器接收请求以后，执行某些动作或者获取某些资源，将响应发送给客户端
 * (3)浏览器接收到资源以后，通过html，css和js来进行构建页面
 * (4)监控事件队列，一次处理其中的一个事件
 * (5)用户进行点击页面进行交互的时候，会执行第四步
 * (6)关闭web页面，应用生命周期结束
 */

/** 
 * js中的全局对象
 * 浏览器暴露给js引擎的主要全局对象是window对象，它代表了包含着一个页面的窗口。
 * window对象是获取所有其他全局对象，全局变量，和浏览器API的访问途径。
 * 全局window对象最重要的属性是document，它代表了当前页面的dom。通过document，可以对document进行增删改
 */

/** 
 * 在页面构建阶段执行js代码
 * 当浏览器在页面构建阶段，遇到了脚本节点，它会停止HTML到DOM的构建，转而开始执行js代码，也就是执行包含脚本元素的全局js代码。
 * 
 * 那么我们为什么要将js代码放在最后面？
 * 因为即使js能在任何程度上修改dom结构，它能够创建新的节点或者移除现有DOM节点，但它不能对未创建的节点进行选择和修改。
 * 如果我们把js代码放在最后，那么我们就不用担心某个HTML元素是否已经加载为DOM
 */

