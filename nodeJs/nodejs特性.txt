https://zhuanlan.zhihu.com/p/30123650

1.从浏览器到node
    node是一个平台，使用javascript作为编程语言，运行在服务端。服务端语言能做的，node一般都能做。

    node是javascript运行环境（runtime），就像浏览器一样，是一个平台。在浏览器中，V8引擎负责解释javascript，
    你在javascript调用的接口都是浏览器实现并提供的，浏览器会调用底层的、由其他语言（C++）实现并封装好的接口来完成任务；
    同样，在node中，也是V8引擎负责解释javascript，而你在javascript调用的浏览器提供的接口就不能用了，
    因为它脱离了浏览器的环境，但是因为你在node环境中，你就可以使用node提供的由C++语言实现的、由javascript封装好的各种接口来完成后端任务。

2.node 架构(分为3层)
    第一层：Node standard library：
        node标准库，也就是node模块提供各种接口的javascript实现，任何javascript代码、npm install 或者你写的模块都在这里

    第二层：Node bindings：
        包括C/C++ bindings（胶水代码）和Add on（添加其他C/C++库时需要自己写的Bindings），
        这一层向下封装了V8和libuv接口，向上提供了基础API接口，是连接javascript和C++的桥梁

    第三层：支撑 Node.js 运行的关键，由 C/C++ 实现
        (1) V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 Node.js 的发动机，
            负责解释javascript，与chrome浏览器相同
        (2) Libuv 是专门为Node.js开发的一个封装库，提供跨平台的异步I/O能力，负责node运行时的线程池调度
        (3) C-ares：提供了异步处理 DNS 相关的能力
        (4) http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等系统底层的访问

    平常我们用到的也就是第一层node各个模块实现的接口。

3.node 架构三层之间如何协作的？
    程序启动，V8引擎会首先解析javascript代码，通过Node bindings来调用C/C++库。
    执行到当前事件时，会把事件放在调用堆栈（stack和heap）处理（可以理解为放进一个工作空间）
    在堆栈中的任何I/O请求都会交给libuv来处理，libuv维持一个线程池，里面是一些工作线程。
    请求会调用这些线程来完成任务，这些线程则调用底层的C/C++库。
    完成时，libuv再把结果返回事件队列等待主线程执行。在此期间，主线程继续执行其他任务。

4.node执行的特性：单线程，非阻塞I/O,事件机制事件环
    (1) 单线程、非阻塞型I／O
    首先，javascript 在浏览器端是单线程的，这是为了避免多线程产生任务冲突的情况；
    其次，java和PHP这类多线程后端语言，为避免同步I/O阻塞，每处理一个连接都会产生一个新线程，
    这样的话在遇到大量并发请求时就会受到物理内存的限制。node 延续了浏览器端单线程javascript，
    只用一个主线程执行javascript，不断循环遍历事件队列，执行事件。
    事实上，主线程发出的I/O请求，都会交给其他线程去完成，其他线程完成后会返回结果放到事件队列。

    在此期间，主线程会继续执行其他任务，也就是在交给libuv后直接返回，继续执行下面的任务，
    主线程只负责循环执行事件队列，因此这种模式称为非阻塞型I／O，性能很好，适用于处理大量并发请求，还能简化开发。

    (2) 事件驱动机制
    还是跟浏览器的差不多。总的来说就是，浏览器端把鼠标点击、键盘按键等定义为事件，而node把网络请求、I／O操作等也看作事件，
    严格来说，一切动作都是事件，这就是事件驱动的思想。在程序启动时，便进入事件循环，不断遍历执行事件队列中产生的事件，
    而在执行过程中，又会产生新的事件，因此称为事件循环。主线程执行事件时，遇到麻烦的I/O请求会交给libuv来调度其他工作线程来帮忙，
    忙完后就会形成事件返回结果到事件队列等待主线程处理。在此期间，主线程会继续执行其他任务。

    cup可以把它的业务交给磁盘服务器，cpu计算和磁盘I/O是瞬间物理并发，因为是不同的原件，而node完成的是I/O任务完成以后，由node会将这个事件调度给cpu某一部分。

5.来阐述下 Node.js 的执行情况：
    把 Node.js 应用程序想象成一家星巴克，一个训练有素的前台服务生（唯一的主线程）在柜台前接受订单。
    当很多顾客同时光临的时候，他们排队（进入事件队列）等候接待；
    每当服务生接待一位顾客，服务生会把订单告知给经理（libuv），
    经理安排相应的专职人员去烹制咖啡（工作线程或者系统特性）。
    这个专职人员会使用不同的原料和咖啡机（底层 C/C++ 组件）按订单要求制作咖啡或甜点，
    通常会有四个这样的专职人员保持在岗待命（线程池），
    高峰期的时候也可以安排更多（不过需要在一早就安排人员来上班，而不能中午临时通知）。
    服务生把订单转交给经理之后不需要等着咖啡制作完成，
    而是直接开始接待下一位顾客（事件循环放进调用堆栈的另一个事件），你可以把当前调用堆栈里的事件看成是站在柜台前正在接受服务的顾客。
    当咖啡完成时，会被发送到顾客队列的最后位置，等它移动到柜台前服务生会叫相应顾客的名字，
    顾客就来取走咖啡（最后这部分在真实生活中听起来有点怪，不过你从程序执行的角度理解就比较合乎情理了）。
