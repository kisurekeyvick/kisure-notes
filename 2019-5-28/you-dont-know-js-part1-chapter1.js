/** 
 * 1.作用域是什么
 */

/** 
 * 1.1编译原理
 * 
 * JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。
 * 与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系统中进行移植。
 * 
 * 传统编译语言的流程，程序编译经历三个步骤：
 * (1)分词/词法分析
 *      将由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元
 *      例如：var a = 2;
 *      会被分解成为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。
 * 
 * (2)解析/语法分析
 *      这个过程是将词法单元流（数组），转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。
 *      这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。
 * 
 * (3)代码生成
 *      将 AST 转换为可执行代码的过程称被称为代码生成。
 *      简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，
 *      用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。
 * 
 * 
 * 对于js来说，js引擎不会有大量的时间用来进行优化。因为js的编译过程不是发生在构建之前的。
 * 大部分的编译发生在代码执行前的几微秒的时间内。
 * 
 * 简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。
 * 因此，JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。
 */

/** 
 * 1.2 理解作用域
 * 
 * 引擎：从头到尾负责整个 JavaScript 程序的编译及执行过程
 * 编译器：负责语法分析及代码生成等脏活累活
 * 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，
 *          确定当前执行的代码对这些标识符的访问权限。
 * 
 * 通过var a = 2;来看引擎和编译器，作用域之间的合作：
 * 编译器：遇到var a,编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。
 *          如果是，编译器会忽略该声明，继续进行编译,否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a
 * 
 *        接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。
 * 
 * 引擎：引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。
 *          如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量
 * 
 * 如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！
 * 
    总结
        变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），
        然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。
 */

/** 
 * 1.3 编译器有话说
 * 引擎会为变量 a 进行 LHS 查询。另外一个查找的类型叫作 RHS
 * 当变量出现在赋值操作的左侧时进行 LHS 查询。
 * 当变量出现在右侧时进行 RHS 查询。
 * 
 * 讲得更准确一点，RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。
 * 
 * 例如：console.log(a);
 *      其中对 a 的引用是一个 RHS 引用，因为这里 a 并没有赋予任何值。
 *      相应地，需要查找并取得 a 的值，这样才能将值传递给 console.log(..)。
 * 
 * 例如：a = 2;
 *      这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，
 *      只是想要为 =2 这个赋值操作找到一个目标。
 */ 

/** 
 * 
 */