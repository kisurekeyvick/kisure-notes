/** 
 * https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%e5%8a%a8%e7%94%bb%e7%ae%97%e6%b3%95/
 * 
 * 关于requestanimationframe的了解
 */

/** 
 * 浏览器的显示频率是16.7ms,如果我们的定时器是10ms的setTimeout，那么总会存在来不及绘制内容的时候。
 * 举个例子：
 * 国庆北京高速，最多每16.7s通过一辆车，结果，突然插入一批setTimeout的军车，强行要10s通过。
 * 显然，这是超负荷的，要想顺利进行，只能让第三辆车直接消失。
 * 然，这是不现实的，于是就有了会堵车！
 * 
 * 同样的，显示器16.7ms刷新间隔之前发生了其他绘制请求(setTimeout)，导致所有第三帧丢失，
 * 继而导致动画断续显示（堵车的感觉），这就是过度绘制带来的问题。
 * 不仅如此，这种计时器频率的降低也会对电池使用寿命造成负面影响，并会降低其他应用的性能。
 * 
 * 这也是为何setTimeout的定时器值推荐最小使用16.7ms的原因（16.7 = 1000 / 60, 即每秒60帧）。
 */

/** 
 * requestAnimationFrame
 * 
 * requestAnimationFrame就是为了这个而出现的。我所做的事情很简单，跟着浏览器的绘制走，
 * 如果浏览设备绘制间隔是16.7ms，那我就这个间隔绘制；如果浏览设备绘制间隔是10ms, 我就10ms绘制。
 * 这样就不会存在过度绘制的问题，动画不会掉帧，自然流畅的说~~
 * 
 * 内部是这么运作的：
 * (1) 浏览器（如页面）每次要洗澡（重绘），就会通知我(requestAnimationFrame)：小丸子，我要洗澡了，你可以跟我一起洗哦！
 * (2) 就算很多个小丸子要一起洗澡，浏览器只要通知一次就可以了。而setTimeout貌似是多个独立绘制。
 * (3) 页面最小化了，或者被Tab切换关灯了。页面是不会洗澡的，自然，小丸子也不会洗澡的（没通知啊）。页面绘制全部停止，资源高效利用。
 */
