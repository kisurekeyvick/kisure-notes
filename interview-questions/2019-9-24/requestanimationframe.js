/** 
 * https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%e5%8a%a8%e7%94%bb%e7%ae%97%e6%b3%95/
 * 
 * 关于requestanimationframe的了解
 */

/** 
 * 浏览器的显示频率是16.7ms,如果我们的定时器是10ms的setTimeout，那么总会存在来不及绘制内容的时候。
 * 举个例子：
 * 国庆北京高速，最多每16.7s通过一辆车，结果，突然插入一批setTimeout的军车，强行要10s通过。
 * 显然，这是超负荷的，要想顺利进行，只能让第三辆车直接消失。
 * 然，这是不现实的，于是就有了会堵车！
 * 
 * 同样的，显示器16.7ms刷新间隔之前发生了其他绘制请求(setTimeout)，导致所有第三帧丢失，
 * 继而导致动画断续显示（堵车的感觉），这就是过度绘制带来的问题。
 * 不仅如此，这种计时器频率的降低也会对电池使用寿命造成负面影响，并会降低其他应用的性能。
 * 
 * 这也是为何setTimeout的定时器值推荐最小使用16.7ms的原因（16.7 = 1000 / 60, 即每秒60帧）。
 */

/** 
 * requestAnimationFrame
 * 
 * requestAnimationFrame就是为了这个而出现的。我所做的事情很简单，跟着浏览器的绘制走，
 * 如果浏览设备绘制间隔是16.7ms，那我就这个间隔绘制；如果浏览设备绘制间隔是10ms, 我就10ms绘制。
 * 这样就不会存在过度绘制的问题，动画不会掉帧，自然流畅的说~~
 * 
 * 内部是这么运作的：
 * (1) 浏览器（如页面）每次要洗澡（重绘），就会通知我(requestAnimationFrame)：小丸子，我要洗澡了，你可以跟我一起洗哦！
 * (2) 就算很多个小丸子要一起洗澡，浏览器只要通知一次就可以了。而setTimeout貌似是多个独立绘制。
 * (3) 页面最小化了，或者被Tab切换关灯了。页面是不会洗澡的，自然，小丸子也不会洗澡的（没通知啊）。页面绘制全部停止，资源高效利用。
 */

/** 
 * 使用requestAnimationFrame有如下好处：
 * (1) 虽说CSS3实现动画即高效又方便，但是对于PC浏览器，IE8, IE9之流,难以实现兼容
 *      IE10+ CSS3实现，IE9-之流JS setTimeout实现。为了修改一个动画，需要改两处。
 *      
 *      requestAnimationFrame跟setTimeout非常类似，都是单回调，用法也类似：
 *      用法：requestAnimationFrame(renderLoop);
 * 
 * (2) 函数节流：在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，
 *      使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，
 *      也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，
 *      因为显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。
 * 
 * (3) CPU节能：使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，
 *      由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。
 *      而requestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，
 *      因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，
 *      动画就从上次停留的地方继续执行，有效节省了CPU开销。
 */
