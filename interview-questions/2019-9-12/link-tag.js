/** 
 * https://juejin.im/post/5b2385f1e51d4558b80b10d1
 * 
 * web性能优化
 * 
 * <link>标签实现预加载功能详解
 */

/** 
 * - preload
 * preload 一个基本的用法就是提前加载资源，尽管大多数基于标记语言的资源能被浏览器的预加载器（preloader）尽早发现，
 * 但不是所有的资源都是基于标记语言的，比如一些隐藏在 css 和 js 中的资源（字体，图片等），
 * 当浏览器发现页面需要这些资源时，重新走一遍加载执行渲染的过程，
 * 会降低用户体验，并且对页面的渲染 造成延迟；
 */

/** 
 * HTML 解析器在创建 DOM 时如果碰上同步脚本（synchronous script)，解析器会停止创建 DOM，转而去执行脚本。
 * 所以，如果资源的获取只发生在解析器创建 DOM时，同步脚本的介入将使网络处于空置状态，
 * 尤其是对外部脚本资源来说，当然，页面内的脚本有时也会导致延迟。
 * 
 * 预加载器（Preloader）的出现就是为了优化这个过程，预加载器通过分析浏览器对 HTML 文档的早期解析结果
 * （这一阶段叫做“令牌化（tokenization）”），找到可能包含资源的标签（tag），并将这些资源的 URL 收集起来。
 * 
 * 令牌化阶段的输出将会送到真正的 HTML 解析器手中，而收集起来的资源 URLs 会和资源类型一起被送到读取器（fetcher）手中，
 * 读取器会根据这些资源对页面加载速度的影响进行有次序地加载。
 */

/** 
 * 预加载的好处：
 * 
 * (1) 让浏览器提前加载指定资源（这里预加载完成后并不执行），在需要执行的时候在执行，
 *      这样将加载和执行分开，可以不阻塞渲染和 window.onload事件。
 * (2) 提前预加载指定资源，特别是字体文件，不会再出现 font 字体在页面渲染出来后，
 *      才加载完毕，然后页面字体闪一下变成预期字体。
 * (3) 带有 onload 事件，可以自定义资源在预加载完毕后的回调函数。
 */

/** 
 * 不要混淆prefetch。
 * <link rel="preload">如果在页面加载后不立即需要资源，请不要使用。
 * 如果您以后只需要它，请使用<link rel="prefetch">。
 */

/** 
 * - prefetch
 * 
 * <link rel="prefetch">要求浏览器在后台下载和缓存资源（如脚本或样式表）。
 * 下载以低优先级发生，因此不会干扰更重要的资源。
 * 当您知道在后续页面上需要该资源并且您希望提前缓存它时，它会很有用。
 * 
 * 下载后，浏览器不会对资源执行任何操作。脚本未执行，样式表未应用。它只是缓存 - 所以当其他东西需要它时，它立即可用。
 */

/** 
 * prefetch 句法:
 * 
 * <link rel="prefetch" href="/style.css" as="style" />
 * href 指向要下载的资源。
 * as 可以是您可以在浏览器中下载的任何内容：
 *  as="style"
 *  as="script"
 *  as="font"
 * 
 * 指定as属性非常重要- 它有助于浏览器确定优先级并正确安排下载
 */
