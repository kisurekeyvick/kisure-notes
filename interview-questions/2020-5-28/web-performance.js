/**
 * 前端性能优化
 */

/**
 * 我们需要知道DNS解析：
 * DNS`解析:将域名解析为ip地址 ,由上往下匹配，只要命中便停止
 * 
 * - 走缓存
 * - 浏览器DNS缓存
 * - 本机DNS缓存
 * - 路由器DNS缓存
 * - 网络运营商服务器DNS缓存 （80%的DNS解析在这完成的）
 * - 递归查询
 * 
 * 优化策略：尽量允许使用浏览器的缓存，能给我们节省大量时间
 */

/**
 * 【优化】浏览器发送请求优化策略：
 * 
 * HTTP协议通信最耗费时间的是建立TCP连接的过程，那我们就可以使用HTTP Keep-Alive，在HTTP早期，每个HTTP请求都要求打开一个TCP socket连接，并且使用一次之后就断开这个TCP连接
 * 使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，
 * 可以减少TCP连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高http服务器的吞吐率
 * (这边我们需要注意：HTTP1.0协议不支持长连接，从HTTP1.1协议以后，连接默认都是长连接)
 * 
 * 
 * (1)  keep-alive timeout：
 * 长时间的tcp连接容易导致系统资源无效占用,所以设置keep-alive timeout时间
 * 使用方式：nginx的keepalive_timeout，和Apache的KeepAliveTimeout。
 * 这个keepalive_timout时间值意味着：一个http产生的tcp连接在传送完最后一个响应后，还需要hold住keepalive_timeout秒后，才开始关闭这个连接。
 * 
 * 
 * (2)  减少HTTP请求次数：
 * 每次HTTP请求都会有请求头，返回响应都会有响应头，多次请求不仅浪费时间而且会让网络传输很多无效的资源
 * 使用前端模块化技术 AMD CMD commonJS ES6等模块化方案将多个文件压缩打包成一个，当然也不能都放在一个文件中，因为这样传输起来可能会很慢，权衡取一个中间值。
 * 
 * 
 * (3)  配置使用懒加载，对于一些用户不立刻使用到的文件到特定的事件触发再请求
 * 
 * 
 * (4)  服务器资源的部署尽量使用同源策略：
 * 因为浏览器为了安全做了同源策略了限制，不然调用就报错(不过现在有很多方式解决这个问题jsonp,nginx反向代理设置，设置请求头)
 * 
 * 
 * (5)  使用preload和dns-prefetch、prefetch：
 * 预请求资源，这种请求方式不会阻塞浏览器的解析，而且能将预请求的资源缓存起来，而且可以设置crossorgin进行跨域资源的缓存，
 * 不会推迟首屏的渲染时间，还会加快后面的加载时间，因为后面的本身需要的资源会直接从缓存中读取，而不会走网络请求
 * 
 * 
 * (6)  使用defer和async属性的脚本：
 * 异步加载的方式，会先发请求,然后JS引擎继续解析下面的内容。
 * async的属性脚本会无序加载，谁先请求回来就立刻加载谁，当请求回来的时候，无论是在DOM解析还是脚本的解析，接下来都先会解析这个asncy脚本，它会阻塞DOM的解析。
 * defer属性的会按HTML结构的按顺序加载，在DOMContentLoad前加载，但是加载之前所有的DOM解析肯定已经完成了，defer属性的脚本不会阻塞DOM的解析，它也叫延迟脚本。
 * 由于实际中它不确定是否在DOMContentLoaded前加载，所以一般只放一个defer的脚本。
 */


/**
 * 【优化】服务器返回响应，浏览器接受到响应数据(使用Nginx反向代理服务器，主要是对服务器端的优化)：
 * 
 * 首先我们需要知道，nginx可以解决：解决跨域，请求过滤，配置gzip，负载均衡，静态资源服务器等
 * 
 * (1)  配置GZIP
 * GZIP是规定的三种标准HTTP压缩格式之一。目前绝大多数的网站都在使用GZIP传输 HTML、CSS、JavaScript 等资源文件。
 * 启用GZip所需的HTTP 最低版本默认值为HTTP/1.1
 * 启用Gzip同时需要客户端和服务端的支持
 */


/**
 * 【优化】浏览器解析优化
 * 
 * (1)  首先我们需要知道浏览器解析数据，绘制渲染页面的过程：
 *  -   先预解析（将需要发送请求的标签的请求发出去）
    -   从上到下解析html文件
    -   遇到HTML标签，调用html解析器将其解析DOM树
    -   遇到css标记，调用css解析器将其解析CSSOM树
    -   link 阻塞 - 为了解决闪屏，所有解决闪屏的样式
    -   style 非阻塞，与闪屏的样式不相关的
    -   将DOM树和CSSOM树结合在一起，形成render树
    -   layout布局 render渲染
    -   遇到script标签，阻塞，调用js解析器解析js代码，可能会修改DOM树，也可能会修改CSSOM树
    -   将DOM树和CSSOM树结合在一起，形成render树
    -   layout布局 render渲染（重排重绘）
    -   script标签的属性 asnyc defer


   (2)  优化点：
    -   需要阻塞的样式使用link引入，不需要的使用style标签
    -   图片比较多的时候，一定要使用懒加载，图片是最需要优化的，webpack4中也要配置图片压缩，能极大压缩图片大小，
            对于新版本浏览器可以使用webp格式图片[webP详解][7]，图片优化对性能提升最大。
    -   webpack4配置 代码分割，提取公共代码成单独模块。方便缓存
        【查看webpack4.js优化教程】
 */


/**
 * 【优化】终结
 * 
 * W3C性能工作组的Longtasks标准也规定了超过50毫秒的任务属于长任务，那么50ms这个数字是怎么得来的呢？
 * 浏览器是单线程的，这意味着同一时间主线程只能处理一个任务，如果一个任务执行时间过长，浏览器则无法执行其他任务，用户会感觉到浏览器被卡死了，
 * 因为他的输入得不到任何响应。为了达到100ms内给出响应，将空闲周期执行的任务限制为50ms意味着，即使用户的输入行为发生在空闲任务刚开始执行，
 * 浏览器仍有剩余的50ms时间用来响应用户输入，而不会产生用户可察觉的延迟。
 * 
 * (1)  使用requestAnimationFrame
 * setTimeout 或 setInterval没有办法保证回调函数什么时候执行，它可能在每一帧的中间执行，也可能在每一帧的最后执行
 * 【查看setInterval-animate.jpg】你会发现，即便我们能保证每一帧总体时间小于16ms，但如果使用定时器触发动画，那么由于定时器的触发时机不确定，所以还是会导致动画丢帧。
 * 【查看requestAnimationFrame.jpg】使用requestAnimationFrame，它可以保证回调函数稳定的在每一帧最开始触发。
 * 
 * (2)  使用transform属性去操作动画，这个属性是由合成器单独处理的，所以使用这个属性可以避免布局与绘制
 * 
 * 
 * (3)  使用translateZ(0)开启图层，减少重绘重排。
 * 特别在移动端，尽量使用transform代替absolute。
 * 创建图层的最佳方式是使用will-change，但某些不支持这个属性的浏览器可以使用3D 变形（transform: translateZ(0)）来强制创建一个新层。
 * 
 * 
 * (4)  样式的切换最好提前定义好class，通过class的切换批量修改样式，避免多次重绘重排
 * 
 * 
 * (5)  多次的append 操作可以先插入到一个新生成的元素中，再一次性插入到页面中。
 * 
 * 
 * (6)  避免强制同步布局
 * 正常情况下浏览器渲染顺序：js修改 -> style计算 -> 触发布局、绘制、合成
 * 但是js可以强制浏览器将布局提前执行
 * 
 * 例如：
 */ 
box.classList.add('big');
var width = box.offsetWidth;
/**
 * 代码中通过新增class修改了元素的样式，随后使用offsetWidth读取元素的宽度，这段代码会导致强制同步布局
 * 在 JavaScript 运行时，上一帧已经渲染好的所有布局值都是已知的，我们可以使用offsetWidth这样的语法获得值；
 * 但这一帧刚修改完的样式浏览器还没渲染呢，这时候使用offsetWidth这样的语法读取元素的宽度，那么浏览器为了告诉我们宽度值，它必须先计算该宽度，这就需要布局。
 */
// 所以正确的做法是先获取宽度，然后再更改样式
var width = box.offsetWidth;
box.classList.add('big');


/**
 * 使用webScoket通信协议：
 * 
 * 仅一次TCP握手就一直保持连接，而且他对二进制数据的传输有更好的支持，可以应用于即时通信，海量高并发场景 
 */ 

/**
 * 如何配置懒加载，懒加载的原理：
 * 
 * 
 */ 