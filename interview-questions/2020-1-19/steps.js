/** 
 * https://mp.weixin.qq.com/s/xOjW11rmqdeqVwVEg_eO2g
 * 
 * 从敲下一行JS代码到这行代码被执行，中间发生了什么？
 */

/** 
 * 编译原理
 * 
 * 编译一般分为三个步骤:
 *      - 词法分析(laxical Analysis) 词法分析的意思就是，将代码块切分成最小的单位。
 *          这些最小单位称为token。比如 var a = 2;
 *          可以切分成var,a,=,2。
 *      - 语法分析(Syntatic Analysis) 将词法单元转换成一个有层级，代表程序语法结构的树，
 *          这就是我们经常说的AST，抽象语法树。
 *      - 代码生成(Code Genaration)
 * 
 * 注意：词法分析跟语法分析不是完全独立的，而是交错运行的。
 *          也就是说，并不是等所有的token都生成之后，才用语法分析器来处理。
 *          一般都是每取得一个token，就开始用语法分析器来处理了。
 */
// 案例
function add (a, b) {
    return a + b
}
// 生成的语法树如图：[ATS.webp]，但是生成的树太长了，图不完整 

/**
 * AST可是所有编译器以及转换器的基础核心，我们常用的babel转码过程就是先将ES6的代码编成AST，
 *      然后转换成ES5的AST，最后由这个AST还原出ES5代码。
 * 
 * 可以说基于AST，你可以随意玩转各种编程语言的相互转换。
 * 
 * 构建语法树，还有一层作用，就是发现语法错误。当JS解析器发现无法构造这个抽象语法树的时候，
 *      就会报语法错误，并结束整个代码块的解析。
 * 
 * 代码生成: V8引擎的编译过程就是将AST转成计算机可以识别的机器指令码，但是它多了一步生成字节码的过程。
 *          首先用解析器生成AST，然后用解释器Ignition根据语法树生成字节码，最后再用TurboFan将字节码生成机器指令码。
 * 
 * 为什么要先转成字节码？
 *      是因为直接生成机器指令码太占内存了。
 */


/** 
 * V8 为什么那么快?
 * 
 * JS的编译过程发生在执行前的那段时间，所以对JS引擎的性能要求特别高。
 * 
 * 那么V8是如何做到的呢？
 * (1) 脚本流
 *      以前的chrome里，网络拿到数据之后，必须经过chrome主线程转发到流解析器。但是，当网络数据到达之后，主线程有可能被其他事情占住，
 *      比如HTML解析，布局，其他JS执行。这样这些数据就没办法被即使解析。
 * 
 *      从Chrome 75开始，V8可以将脚本直接从网络流传输到流解析器中，而无需等待chrome主线程。
 * 
 *      这意味着脚本一旦开始加载，V8就会在单独的线程上解析。这样下载脚本完成后几乎立即完成解析，从而缩短页面加载时间。
 * 
 * (2) 字节码缓存
 *      首次访问页面的时候，JS代码会被编译成字节码。当再次访问同一个页面的时候，会直接复用首次解析出来的字节码。
 *      这样就省去了下载，解析，编译的步骤，可以使chrome节省大约40%的时间。
 * 
 * (3) 内联
 *      如果一个函数内部调用其他函数，那么编译器会直接函数中将要执行的内容放到主函数里。
 * 
 * (4) 隐藏类
 *      对于C++/Java，访问指令可以在编译阶段生成。
 *      因为它们的每一个变量都有指定的类型。所以一个对象包含什么成员，这些成员是什么类型，在对象中的偏移量都可以在编译阶段就确定了。
 *      那么在CPU执行的时候就轻松了，要访问这个对象中的某个变量的时候，直接用对象的首地址加偏移量就可以访问到。
 * 
 *      但是JS是动态语言，运行的时候不仅可以随意换类型，还可以动态添加删除属性。所以访问对象属性完全得运行的时候才能决定。
 * 
 *      如果JS引擎每次都需要进行动态查询，会造成大量的性能损耗。所以V8引入了隐藏类机制。
 *      在初始化对象时候，会给他创建一个隐藏类，而后增删属性都会在创建一个隐藏类或者查找之前已经创建好的类。
 * 
 *      那么这些隐藏类里的成员对于这个类来说就是固定的。所以他们的偏移量对于这个类来说也是固定的，
 *      那么在后续再次调用的时候就能很快的定位到他的位置。
 */
// 内联的案例： 
function add(a, b) {
    return a + b;
}

function calculateTwoPlusFive() {
    var sum;
    for (var i = 0; i <= 1000000000; i++) {
        sum =add(2+5);
    }
}

calculateTwoPlusFive();

// 编译后：
function add(a, b) {
    return a + b;
}

function calculateTwoPlusFive() {
    var sum;
    for (var i=0;i<=1000000000;i++){
        sum = 2 + 5;
    }
}

calculateTwoPlusFive();


// 隐藏类
function Person(name, age) {
    this.name = name;
    this.age = age;
}

const daisy = new Person("daisy", 32);
daisy.email = "daisy@qq.com";
daisy.job = "engineer";

/** 
 * [隐藏类.webp]
 * 
 * 首先两个new Person（）的时候，生成的隐藏类为C0，因为此时没有任何属性。当执行this.name = name;
 * 的时候多了一个属性，于是又生成了C1。后面同理，到C2生成的时候，daisy跟alice的隐藏类都是一样的，就是C2，此时有两个属性。
 * 
 * 但是后面由于动态添加属性的顺序不同，就造成了属性在类中的偏移量不同，也会生成不同的隐藏类。
 * 这样就没办法共享隐藏类，导致浪费资源生成新的隐藏类。
 * 
 * 所以我们动态赋值的时候，尽量保证顺序也是一致的。
 */

/** 
 * 热点函数会被直接编译成机器码
 * 
 * v8在运行的时候，会采集JS代码运行数据。当发现某个函数被频繁调用，那么就会将它标记成热点函数，
 * 并且认为他是一个类型稳定的函数。这时候会将它生成更为高效的机器码。
 * 
 * 但是在后面的运行中，万一类型发生变化，V8又要回退到字节码。
 */

// 热点函数在运行时，如果传入的参数发生类型变化，V8会把热点函数回退到字节码
function add(a, b){
    return a + b;
}

// 这里使用add的时候一直传入number类型
for(var i=0; i<10000; ++i){
    add(i, i);
}

// 最后却传了string，会退回到字节码，会使得性能受损
add('a', 'b');


/** 
 * 下面两段代码可以猜猜谁的执行效率高？
 */
// 片段 1
var person = {
    add: function(a, b){
        return a + b;
    } 
};
obj.name = 'li';    
    
// 片段 2
var person = {
    add: function(a, b){
            return a + b;
        },
    name: 'li'
};

/** 
 * 答案是2。结合前面知识，我们可以知道，方法一中动态添加属性会生成一个新的隐藏类。
 * 如果add函数此时已经被转成机器码，那么对于方法一来说，就没办法复用了。因为类都是新的了。
 * 所以函数参数类型越稳定，对象内部属性越稳定，V8的效率越高。
 */


/** 
 * 总结
 * 
 * 从敲下一段JS代码到它最终被计算机理解并执行，中间经历了词法分析，语法分析，生成机器码，执行机器码的过程。
 * 
 * 当然这个编译的过程是很复杂的，尤其js还是动态语言，对于js引擎的性能要求就很高了。
 * 
 * V8做了很多事情来提升浏览器的性能，其中包括但不限于：
 *      (1) 脚本流：下载的同时就已经在解析，节省时间
 *      (2) 字节码缓存：访问同一个页面的时候直接复用之前的字节码，不在重新编译生成
 *      (3) 内联：将主函数中调用的函数，直接换成将要执行的语句
 *      (4) 隐藏类：通过隐藏类快速定位到动态加入的属性 注意：动态加入的属性顺序不一样，会造成生成不同的隐藏类，
 *                  我们动态赋值同一个构造函数对象的时候，尽量保证顺序也是一致的。
 *      (5)热点函数编译成机器码：将常用的函数直接一步到位编成机器码。注意：常用的函数传入的类型保持固定。
 *                  并且对象的属性越稳定，越有利于性能。
 */ 