/**
 * https://juejin.im/post/5d12b308f265da1b7c612746
 * 
 * JS的日期的知识
 */

/** 
 * 1. 时区
 * 
 * 世界有数百个时区。 在JavaScript中，我们只关心两个， 本地时间和协调世界时(UTC)
 * (1) 本地时间是指你的计算机所在的时区
 * (2) UTC实际上是格林威治标准时间(GMT)的同义词
 * 
 * 默认情况下，JS中的几乎每个日期方法（除了一个）都是本地时间。 
 * 只有指定UTC，才能获得 UTC 时间 。
 */

/** 
 * 2. 创建日期
 * 
 * 可以使用 new Date() 来创建日期，传入的参数通常有4种常用的方式：
 * (1) 使用日期字符串参数
 *      new Date('1988-03-21')
 *      之所以不能用 new Date('21-03-1988'),是因为在世界的不同地方以不同的方式解释日期字符串。 例如11-06-2019是2019年6月11日还是 2019年11月6日。
 *      你不能确定我指的是哪一个，除非你知道我正在使用的日期系统。
 * 
 *      在JS中，如果要使用日期字符串参数，则需要使用全球都能接受的格式：
*           YYYY：4位数年份
            MM：两位数月份(即 1月为01,12月为12)
            DD：两位数的日期(0到31)
            -：日期分隔符
            T：表示开始时间
            HH：24位小时数（0到23）
            mm：分钟（0到59）
            ss：秒（0到59）
            sss：毫秒（0到999）
            :：时间分隔符
            Z：如果存在Z，则日期将设置为UTC，如果Z不存在，则为本地时间。

        例如：new Date('2019-06-11')    
        你住在**格林威治标准时间(GMT)**晚的的地区，你会得到一个日期是6月10日
        你住在比格林威治标准时间早的地区，才会等得到6月11日的日期

        发生这种情况是因为日期字符串参数的方法具有特殊行为：如果创建日期（未指定时间），则会获得UTC格式设置的日期。

        在上面的场景中，使用new Date('2019-06-11') 创建日期时，实际上创建的日期是2019年6月11日，UTC时间上午12点。
        这就是为什么住在格林尼治标准时间之后的地区的人得到的是6月10日而不是6月11日。

        如果要使用日期字符串参数方法在“本地时间”中创建日期，则需要包括时间。如果包含时间，则需要至少写入HH和mm。
 * 
 * (2) 使用一系列的参数
 *      最多可以传入七个参数来创建日期/时间
 * 
 *      Year：4位数年份
        Month：一年中的某月（0-11）
        Day：每月的某天（1-31），如果省略，则默认为1。
        Hour：一天中的小时（0-23），如果省略，则默认为0。
        Minutes：分钟（0-59），如果省略，则默认为0。
        Seconds：秒（0-59），如果省略，则默认为0。
        Milliseconds：毫秒（0-999），如果省略，则默认为0

        许多开发人员比较少用这种方式，因为它看起来很复杂，但它实际上非常简单。
        可以从左到右记忆:年、月、日、小时、分钟、秒和毫秒。

        // 11th June 2019, 5:23:59am, Local Time
        new Date(2019, 5, 11, 5, 23, 59)
 * 
 * (3) 时间戳参数
 * (4) 不带参数
 */

/**
 * 3. 格式化日期
 * 
 * 如果需要创建自定义格式的时间，可以使用以下方法：
 * (1) getHours：获取当地时间获取小时数（0-23）
 * (2) getMinutes:获取本地时间获取分钟(0-59)
 * (3) getSeconds：获取本地时间获取秒数（0-59）
 * (4) getMilliseconds:获取本地时间获取毫秒(0-999)
 */

/**
 * 4. 日期的比较
 * 
 * (1) 比较日期的前后，可以直接使用>, <, >= 和 <= 时行比较。
 * const earlier = new Date(2019, 0, 26)
 * const later = new Date(2019, 0, 27)
 * console.log(earlier < later) // true
 * 
 * (2) 比较两个日期是否一样，就比较麻烦，不能直接用 == 或 ===
 * const a = new Date(2019, 0, 26)
 * const b = new Date(2019, 0, 26)
 * console.log(a === b) // false
 * 
 * 可以getTime获取它们的时间戳，用时间戳进行比较
 * const isSameTime = (a, b) => {
 *      return a.getTime() === b.getTime()
 * }
 * 
 * 如果只想检查两个日期是否在同一天，可以比较他们的getFullYear，getMonth和getDate值
 * const isSameDay = (a, b) => {
    return a.getFullYear() === b.getFullYear() &&
        a.getMonth() === b.getMonth() &&
        a.getDate()=== b.getDate()
    }

    const a = new Date(2019, 0, 26, 10) // 26 Jan 2019, 10am
    const b = new Date(2019, 0, 26, 12) // 26 Jan 2019, 12pm
    console.log(isSameDay(a, b)) // true
 */

/** 
 * 5. 从另一个日期获取日期
 * 
 * 有两种可能的情况，希望从另一个日期获得一个日期
 * (1) 设置另一个日期特定的日期/时间值
 * (2) 从另一个日期添加/减去增量
 * 
 * 设置另一个日期特定的日期/时间值
 * 可以使用以下方法设置另一个日期的日期/时间
 * (1) setFullYear: 设置年份
 * (2) setMonth：设置月份
 * (3) setDate：设置每月的某一天
 * (4) setHours：设置时
 * (5) setMinutes：设置分
 * (6) setSeconds：设置秒
 * (7) setMilliseconds：设置毫秒
 * 
 * 如果想将日期设置为每月15日，可以使用setDate(15)
 * const d = new Date(2019, 0, 10)
 * d.setDate(15)
 * console.log(d) // 15 January 2019
 * 
 * 注意：上面的setter方法会改变原始日期对象。 
 * 在实际中，我们不应该改变对象，应该在新的日期对象上执行这些操作。
 * const d = new Date(2019, 0, 10)
 * const newDate = new Date(d)
 * newDate.setMonth(5)
 * 
 * console.log(d) // 10 January 2019
 * console.log(newDate) // 10 June 2019
 */

/** 
 * 6. 自动日期校正
 * 
 * 如果为Date提供一个超出其可接受范围的值，JS 将自动重新计算日期
 * 如下所示，假设我们把日期定在2019年3月33日，日历上没有33日，JS 会自动将3月33日调整为4月2日。
 * new Date(2019, 2, 33);
 */

